// jsonpg_state.c generated by gen_state from jsonpg_state.json and jsp_state.skel.c
// manual edits to jsonpg_state.skel.c will be reflected in jsonpg_state.c
// manual edits to jsonpg_state.c will be discarded

#include <stdint.h>

// Macros for code produced by gen_state
#define if_config(X)            (p->flags & (X))
#define accept_null(X)          ((X), JSONPG_NULL)
#define accept_true(X)          ((X), JSONPG_TRUE)
#define accept_false(X)         ((X), JSONPG_FALSE)
#define push_token(X)           push_token(p, (X))
#define pop_token()             pop_token(p)
#define ifpeek_token(X)         ((X) == p->tokens[p->token_ptr - 1].type)
#define swap_token(X)           (p->tokens[p->token_ptr - 1].type = (X))
#define push_state(X)           (p->push_state = (X))
#define pop_state()             (p->push_state)
#define begin_object()          begin_object(p)
#define end_object()            end_object(p)
#define begin_array()           begin_array(p)
#define end_array()             end_array(p)
#define in_object()             (peek_stack(p) == STACK_OBJECT)
#define in_array()              (peek_stack(p) == STACK_ARRAY)
#define accept_integer(X)       accept_integer(p, (X))
#define accept_real(X)          accept_real(p, (X))
#define accept_string(X)        accept_string(p, (X))
#define accept_key(X)           accept_key(p, (X))
#define accept_sq_string(X)     accept_string(X)
#define accept_sq_key(X)        accept_key(X)
#define accept_nq_string(X)     accept_string(X)
#define accept_nq_key(X)        accept_key(X)
#define process_escape(X)       process_escape(p, (X))
#define process_escape_chars(X) process_escape_chars(p, (X))
#define process_escape_u(X)     process_escape_u(p, (X))

uint8_t state_map[][256] = {
<= map

};

typedef enum {
<= enums
,
        state_initial = JSONPG_STATE_INITIAL,
        state_error   = JSONPG_STATE_ERROR
} state;

jsonpg_type jsonpg_parse_next(jsonpg_parser p) {
        if(p->state == state_initial) {
                p->push_state = 
                        (p->flags & JSONPG_FLAG_IS_OBJECT)
                                ? state_w_key
                                : state_w_value;
                p->state = state_whitespace;
        }

        while(1) {
                while(p->current < p->last) {
                        state current_state = state_map[p->state][*p->current];
                        if(!(current_state & 0x80)) {
                                p->state = current_state;
                                p->current++;
                                continue;
                        }

                        jsonpg_type result = JSONPG_NONE;
                        state new_state = state_error;
                        int incr = 1;
                        switch((int)current_state) {
<= code

                        }

                        if(new_state == state_error)
                                return parse_error(p);

                        p->state = new_state;
                        p->current += incr;

                        if(result != JSONPG_NONE) {
                                return result;
                        }
                }
                if(p->seen_eof)
                        return (p->token_ptr == 0)
                               ? JSONPG_EOF
                               : parse_error(p);
                else if(-1 == parser_read_next(p))
                        return file_read_error(p);
        }
}
